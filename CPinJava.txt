Quicklist:


If you know the range of numbers it is better to use CountSort as it is only O(n) when compared to comparison based sorting.

To sort arraylist use :

Collections.sort(ArrayList  variable)

To reverse Arraylist use :

Collections.reverse(Arraylist variable)

To perform binary search on collections :

Collections.binarSearch(variable, 6);


To set a specific bit j in a number to 1

S |= (1 << j)

to check if a specific bit j is set to 1:
 right shift and bitwise and

 to clear / turn off  a specific bit j :

 S &= ~(1 << j)

 page 60 cp3



 Double ended queue : Dequeue

---------------------------

To convert int to char 

char ch = Character.forDigit(i, RADIX);

To convert char to int .

int i2 = Character.digit(ch, RADIX);





------------------------


ASCII value of integer 0 is 48

if we are adding an integer and a char ex: 2 + '0' :  then 0 is converted to ascii, added and then printed. 

48 +2 = 50 which is the ascii character of "2".  So char "2" will be printed.


If you want to get the digits in a number in terms of chars :

char bla = (char)(number % 10 + '0');

If we do casting of an number into char data type then we will get ascii of it, as above.

(char)(an integer  number) = we will get ascii value  of that integer number . 


To convert an integer number to "an integer number" ie string representation of that number use : Integer.toString(an integer number)



------------------------


GCD Euclid's algorithm :

GCD(n,m) == GCD(m, n mod m)



-----------------------------


 Queue and Dequeue are abstract classes and need to be initiated as LinkedList


Queue<Integer> q = new LinkedList<Integer>();

If array needs to only contain 0/1 then use 

Java has BitSet data structure to implement this.




For binary search in java

Arrays.binarySearch(array,key);

Arrays.sort();


Maximum size of array is 10^8

Return only part of an array :

Arrays.copyOfRange(arr,startIndex,endIndex);
startIndex is inclusive
endIndex is exclusive.

//Check for Arrays.parallelSort();


To get log base 2 do this 
int iterations = (int)(Math.log(a)/ Math.log(2));

always ask yourself if you may need to print a variable to console to cross check.


To generate random int's between a range:

	(new Random().nextInt(end - start + 1) +  start)

To generate random long's between a range :

	long number = (long) (rand.nextDouble()*max);

	long number = x+(((long)r.nextDouble())*(y-x))


To find min:

Arrays.stream(arr).min().getAsInt()

to find max 

Arrays.stream(arr).max().getAsInt()

to find sum of els of array:

Arrays.stream(arr).sum()

 to find average of els of an array

 Arrays.stream(arr).average()/(double)arr.length;



 if in case the list is empty , then java 8 has an optional feature orElse()

 Arrays.stream(arr).average().orElse(0d);

 Now if we want to make use of all the processors that are available to do above operations:
 If the size of the array arr is quite small , then using the parallel() will slow down the execution of the program, hence use parallel() only when the size of the array is large

  Arrays.stream(arr).parallel().average().orElse(0d);

 Similarly for others:

 Arrays.stream(arr).parallel().min().getAsInt();  // similar for max

 In a hashmap, using map.containsKey() is slow. Instead we can use map.get(object) and then do the work:


 Integer count = map.get(input);   // Here we cant use the primitive int as ,int by default stores 0 and cannot store null.
 if(count == null) count = 0;

 map.put(input,count+1);

For directly incrementing you cn do something like this :
 
 myMap.put(key, myMap.get(key) + 1)


String, Integer all are immutable. if we want to use mutable for Integer we need to use AtomicInteger.

------------------------------------

For using built in binary search 

Arrays.binarySearch(int[] array , int key)

if present in the array will return the index which will be >=0 , if not present will return a negative number.





To print an array :

System.out.println(Arrays.toString(array));


TreeMap in java is equivalent of map in cpp

PriorityQueue in java is binary Heap in java


ArrayList in java is equivalent to vector in cpp










--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
HashMap doesnt maintain order of insertion into the map.



int is a primitive type. Variables of type int store the actual binary value for the integer you want to represent. int.parseInt("1") doesn't make sense because int is not a class and therefore doesn't have any methods.



Integer is a class, no different from any other in the Java language. Variables of type Integer store references to Integer objects, just as with any other reference (object) type. Integer.parseInt("1") is a call to the static method parseInt from class Integer (note that this method actually returns an int and not an Integer).

Note that every primitive type in Java has an equivalent wrapper class:
	
byte has Byte
short has Short
int has Integer
long has Long
boolean has Boolean
char has Character
float has Float
double has Double

Wrapper classes inherit from Object class, and primitive don't. So it can be used in collections with Object reference or with Generics.


To take space seperated input:


BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());
		int k = Integer.parseInt(st.nextToken());	
		String str = st.nextToken();

Here first 2 space seperated inputs are numbers hence the conversion , whereas the 3rd one is the direct string.


-------------------------------------------------------------------------------------


for the variables which do not change very often , mark them as final .

final StringBuilder stringBuilder = new StringBuilder();

Try to avoid object creation in java, even if you create objects it should not be of the order n^2 or even nlogn

Write most of the code in a solver class and in the main class you should just be printing it by creating an object within sysout


System.out.println(new Solver().solve(a,b,c,d)) 

This^ should be the way you write code for competitive programming.

For binary search in java

Arrays.binarySearch(array,key);

Arrays.sort();

//Check for Arrays.parallelSort();


String str = "abcd";

str.indexOf("b"); 

The above line of code is an n^2 operation and should be used only if absolutely necessary.

int max = Integer.MAX_VALUE

Sets the value to max dd

in Test cases
@Test
public void Test1()
{
	assertArrayEquals(new int[]{1,2,3,4}, solver.solve(new int[] {4,3,2,1}))
}


JUnit does not allow static methods to be tested meaning main method is static hence we need to seperate out the logic
in a solver class and then  test by creating objects of the solver class.



											FAST OUTPUT :



system.out.println is very slow.

for(int testcases = br.readLine(); testcases > 0 ; testcases--)
{
	sysout("answer");
}

this is slow as we are calling sysout for every iteration.

Instead we can do something that will output only once.

String str = "";
for(int testcases = br.readLine(); testcases > 0 ; testcases--)
{
	str += "answer";
}


sysout(str);

// In java strings are immutable => when we are doing str += "answer" , it is actually creating a new string doing the += operation and then assigning the reference "str" to the newly created object.


Now to avoid this :

We need to use StringBuffer or StringBuilder . StringBuffer is implelemented for concurrent input. Which we would not need
for the purpose competitive programming

We can use StringBuilder in place of Strings.
So , the above code becomes :


StringBuilder stringBuilder = new StringBuilder();
for(int testcases = br.readLine(); testcases > 0 ; testcases--)
{
	stringBuilder.append("answer").append("\n");
}

// String builder doesnt append the \n character by default as comapared to println. Hence we need to explicitly do that.


Now to print out we just use sysout only once.

System.out.println(stringBuilder);


	To totally avoid out.println we can do this :

		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		bw.write(stringBuilder);


									MULTIPLE SOLVERS:


In this approach , we will have 2 kinds of solutions :

1) the first one is the one which is a bruteforce solver where you know it is going to be correct 

2) the second one is the one which you are going to submit and need some clarity on.

You use the bruteforce solution , which you are quite sure of the answer , to compare it to the actual solution which you are going to submit. It helps in generating a lot of test cases as well as making sure you are getting the right answers by comparing it with the brute force solver.

For example : If you are implementing KMP algorithm in strings , you use the .indexOf() function as the bruteforce solver , and we know that the bruteforce solver, in this case the indexOf is n^2 algorithm . We just use this to cross check the answer which we would get from the kmp algo.


-----------------------------

To find a random number between i and j both inclusive

 Random random = new Random();
        int p = random.nextInt(j-i + 1) + i;


--------------------------

Default values for elements of an integer array in java is 0

For other data types , if we want to initialize with a specific value we can use Arrays.fill();

--------------------------


instead of :

        for(int i = 0; i < size; i++)
        {
           
            area = arr[i] * width;
            if(max < arr[i]*  Math.abs(rMin[i]-1 - (lMin[i]))) max = arr[i] *  Math.abs(rMin[i]-1 - (lMin[i]));
        }


		int width = 0,area = 0;
        for(int i = 0; i < size; i++)
        {
            width = Math.abs(rMin[i]-1 - (lMin[i]));
            area = arr[i] * width;
            if(max < area) max = area;
        }


This will make the code look alot more meaningful than the first approach. Even though the first approach is shorter it gets a lot harder to debug when in a difficult situation as if you have variables you can "watch" them in debug mode.





------------------------------


StringBuilder and StringBuffer are Mutable unlike String which is immutable.

StringBuilder is NOT threadsafe where as StringBuffer is threadsafe. StringBuilder is faster than StringBuffer in a single thread process.


When using stringbuilder if you want to append an entire array with appending a specific character after each element of the array . Dont do this
Instead , just return a stringBuilder object from the function instead of returning the entire array. Create a stringBUilder and as and when we are 
entering values into the array push into stringbuilder and in the end just return the stringbuilder.


-------------------------

Arraylist has dynamic size. Arraylist is faster than Vector


ArrayList<Integer> list = new ArrayList<>();


list.add(2); // to add.

To get the value at an index :

list.get(1) // gets value at index location 1


To remove a specific index 

list.remove(3); // All the elements ahead will be moved accordingly  



----------------------------

								Strings in Java:

Reverse a string :

THere is no inbuilt method to reverse a string  in java. But StringBuilder has inbuilt reverse function. 

So use StringBuilder to build the string and reverse.

        String s = "hello";
        StringBuilder sb = new StringBuilder(s);
        System.out.println(sb.reverse());

        //This will reverse  the string

Another way for stringbuilder is :

	StringBuilder str = new StringBuilder();
	str.append("GFG");

To add strings to a stringbuilder, we need to use .append();



String Tokenizer :


StringTokenizer(String str, String delim, boolean flag):


The first two parameters have same meaning.  The flag 
serves following purpose.

If the flag is false, delimiter characters serve to 
separate tokens. For example, if string is "hello geeks"
and delimiter is " ", then tokens are "hello" and "geeks".

If the flag is true, delimiter characters are 
considered to be tokens. For example, if string is "hello
 geeks" and delimiter is " ", then tokens are "hello", " " 
and "geeks".


String Joiner:

StringJoiner sj1 = new StringJoiner(",");
sj2.add("Hello").add("Jim"); 
System.out.println(sj1);

// will print "Hello,Jim"


To access string as an array :


String result = "Abcd";

result.charAt(3


-------------------------------------------------------------------------------------------


			Arrays in Java:

			To copy an array we can iterate and copy element one after another, or use clone() or  System.arraycopy()


			System.arraycopy() is faster than clone() but is a bit difficult to remember. 

			 int b[] = new int[a.length]; 
  
	        // Copy elements of a[] to b[] 
	        System.arraycopy(a, 0, b, 0, a.length); 

	        second arg is the starting position of src array 
	        4rth arg is the starting position of dest array and last arg is for what length we want to copy.

	        Another way to remember is :

	        System.arraycopy(a, 0, b, 0, a.length); 

	        1st arg: src array
	        2nd arg: src starting position
	        3rd arg: dest array
	        4rth arg: dest starting position
	        5th  arg: length of subarray of src to copy


	        If you forget these args you can just use clone() :

	        int b[] = a.clone(); 



	       To reverse an int[] array there is  no direct way to reverse. We can either go and manually swap or we can convert int[]  to Integer[] and then 

	       use Collections.reverse().But reverse in collecctions works only on Lists, so we use Arrays.asList to convert Interger[] to List and then reverse.


	       public static Integer[] toConvertInteger(int[] ids) 
	       {

			  Integer[] newArray = new Integer[ids.length];
			     for (int i = 0; i < ids.length; i++) 
			     {
			       newArray[i] = Integer.valueOf(ids[i]);
			     }
			   return newArray;
			} 


			Collections.reverse(Arrays.asList(a)); 


			To convert Integer[] to int[]:

			int[] newArray = new int[WrapperArray.length];
		      for (int i = 0; i < WrapperArray.length; i++) {
		         newArray[i] = WrapperArray[i].intValue();
		      }
		   return newArray;




Integer,Float,Double are wrapper classes for int, float, double respectively. To store into wrapper class use valueOf :

	Integer i = Integer.valueOf(k); // similarly for other classes.

To get value from wrapper class and store in primitive class :

	int k = Integer.intValue(i); // similarly for other classes.

------------------------------------------------------------------------

To convert ArrayList to LinkedList

List<Integer> arraylist = new ArrayList<>();
arraylist.add(1);
arraylist.add(2);
arraylist.add(3);
arraylist.add(4);



//To convert to LinkedList :

List<Integer> list = new LinkedList<>(arraylist);


--------------------------------------------------------------------

arraylist.get(1) is O(1) time complexity.



--------------------------------------------------------------------

To convert from 1 data type to another use "valueOf" which is available for all built-in data types in java :


To convert  string "32" to int 

int i = Integer.valueOf("32");

Similarly from string to double/float as above. Use Double.valueOf("32.2333") instead.




To convert int 32 to String "32" :

String s = String.valueOf(32);

Similarly for float to String as above.

String s = String.valueOf(32.3233);




------------------------------------------------------------


ArrayList and LinkedList are implemented from List.

To convert from ArrayList to LinkedList:

List<Integer> list = new LinkedList<>(arraylist);


To convert from LinkedListt to ArrayList :

List<Integer> list = new ArrayList<>(linkedlist);


---------------------------------------------------------------

Similarly as above HashSet and Treeset(indirectly) are implemented from Set:

Hashset is unordered where as Treeset is ordered.


Treeset 

	

